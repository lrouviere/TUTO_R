[
["index.html", "Introduction à R Présentation", " Introduction à R Laurent Rouvière 2020-06-19 Présentation Ce tutoriel présente une introduction au logiciel R. Les thèmes suivants sont abordés : Présentation du logiciel, environnement Rstudio, reporting avec Rmarkdown Objets R Manipulation des données (essentiellement avec dplyr) Visualisation de données (représentations standards et avec ggplot2) Cartes dynamiques avec leaflet Régression : ajustement de modèles, formules, prévisions… On pourra trouver des supports de cours ainsi que les données utilisées à l’adresse suivante https://lrouviere.github.io/intro_R/. Des compléments sur les outils du tidyverse pourront être consultés dans le très complet document de Barnier (2020) ainsi que les ouvrages Wickham and Grolemund (2017) et Cornillon et al. (2018). Références "],
["intro.html", "Chapitre 1 Introduction 1.1 R Script 1.2 Packages 1.3 Markdown", " Chapitre 1 Introduction R est un logiciel libre et gratuit principalement dédié aux analyses statistiques et aux représentations graphiques. Il est gratuit et librement distribué par le CRAN (Comprehensive R Archive Network) à l’adresse suivante : https://www.r-project.org. L’installation varie d’un système d’exploitation à l’autre (Windows, Mac OS, Linux) mais elle est relativement simple, il suffit de suivre les instructions. RStudio est une interface facilitant l’utilisation de R. Elle est également gratuite et librement distribuée à l’adresse https://www.rstudio.com. L’interface RStudio est divisée en 4 fenêtres : Console où on peut entrer et exécuter des commandes (taper 1+2) Environnement, History où on peut visualiser les objets construits (taper a &lt;- 1+2 dans la console) Files, Plots… où on peut visualiser les répertoires et fichiers de l’espace de travail, les graphiques, intaller des packages… R script où on conserve les lignes de commandes ainsi que les commentaires sur le travail effectué. Il faut penser à sauvegarder régulièrement ce fichier. 1.1 R Script Il existe différentes façons de travailler sur RStudio. De façon classique, on peut ouvrir un script. entrer les commandes dans le script. regarder les sorties dans la console (en cliquant sur le bouton run). sauver le script. 1.2 Packages Un package est une ensemble de programmes et fonctions R qui complètent les fonctions existantes par défaut dans le logiciel. Un package est généralement dédié à une méthode ou un champ d’application spécifique. Il existe plus de 13 000 packages disponibles sur le CRAN https://cran.r-project.org. On installe un package en utilisant le fonction install.packages dans la console. ou ou cliquant sur le bouton Packages. Une fois le package installé sur la machine, on l’installe avec la fonction library : &gt; install.packages(package.name) &gt; library(packages.name) Exercice 1.1 (Installation et chargement) Exécuter &gt; iris %&gt;% summarize(mean_Petal=mean(Petal.Length)) Que se passe t-il ? Installer et charger le package tidyverse et ré-executer le code précédent. &gt; install.packages(&quot;tidyverse&quot;) &gt; library(tidyverse) &gt; iris %&gt;% summarize(mean_Petal=mean(Petal.Length)) mean_Petal 1 3.758 1.3 Markdown mardown est un package qui permet de créer différents types de documents : rapports au format pdf ou rtf pages web html diaporama pour des présentations (html, beamer, PowerPoint…) applications web interactives … qui comportent du code R. 1.3.1 Syntaxe La syntaxe s’apprend assez facilement (il faut pratiquer), on pourra trouver un descriptif synthétique dans la cheatsheet dédié à Rmarkdown. Par exemple : Caractère en italique ou gras : *italique* et **gras** donne italique et gras Listes non ordonnées - item 1 - item 2 produit item 1 item 2 liste ordonnée : 1. item 1 2. item 2 produit item 1 item 2 tableau : | | Col1 | Col2 | Col3 | |:----:|:----:|:----:|:----:| | Row1 | 1 | 2 | 3 | | Row2 | 1 | 2 | 3 | renvoie Col1 Col2 Col3 Row1 1 2 3 Row2 1 2 3 équation latex : $$\\int_a^b f(x)dx=1$$ renvoie \\[\\int_a^b f(x)dx=1\\] 1.3.2 Les chunks Le code R doit être écrit dans des chunks. On peut insérer des chunks avec : la raccourci clavier Ctrl + Alt + I (OS X: Cmd + Option + I) la bouton Insert -&gt; R en tapant : ```{r} commandes... ``` Plusieurs options peuvent être spécifiés au chunk en fonction de ce que l’on souhaite voir dans le document, par exemple : echo : TRUEor FALSE pour spécifier si on souhaite afficher le code ; eval : TRUEor FALSE pour spécifier si le code doit être évalusé ou non ; results : hide si on ne veut pas voir la sortie du code. On pourra trouver l’ensemble des options disponibles sur cette page : https://yihui.org/knitr/options/ Exercice 1.2 (Premier document) Ouvrir un document mardown (File -&gt; New File -&gt; R Markdown). Cliquer sur le bouton Knit et visualiser la sortie html. Obtenir une sortie pdf. Modifier le document en créant une section Cosinus dans laquelle on tracera la fonction cosinus, on pourra utiliser le code suivant dans un chunk. &gt; x &lt;- seq(-2*pi,2*pi,by=0.01) &gt; y &lt;- cos(x) &gt; plot(x,y,type=&quot;l&quot;) Ajouter une section Sinus dans laquelle on tracera la fonction sinus. 1.3.3 Notebook L’environnement notebook fonctionne exactement comme un document markdown mais permet de visualiser la sortie eu format html sans avoir à recompiler le document en entier. Cet environnement est donc souvent privilégié pendant la réalisation d’un projet en science des données. Pour créer un notebook, on peut passer par RStudio : File -&gt; New File -&gt; R Notebook ou simplement remplacer output: html_document par output: html_notebook dans l’entête d’un document markdown. Exercice 1.3 (Premier document) Transformer le document markdown de l’exercice précédent en notebook. On pourra visualier la sortie en cliquant sur Preview. 1.3.4 Diaporama R Rstudio propose aussi différents environnements pour construire des diaporamas. On pourra utiliser le menu File -&gt; New File -&gt; R Markdown -&gt; Presentation, puis sélectionner le format ioslides ou slidy. On utilisera la même syntaxe que pour les documents markdown. Les slides sont séparés par le symbole ## et les codes R sont toujours insérés dans des chunks. Exercice 1.4 (Premier document) Créer 2 diapositives : Titre: Cosinus où on tracera la fonction cosinus. Titre: Sinus où on tracera la fonction sinus. En modifiant les options des chunks modifier les diapositives de manière à ne pas voir le code R mais voir les graphiques voir uniquement le code R mais pas les graphiques. 1.3.5 Exemples de styles de documents markdown Par défaut l’entête d’un document markdown est de la forme --- title: &quot;Mon document&quot; author: &quot;Laurent Rouviere&quot; date: &quot;6/18/2020&quot; output: html_document --- Il existe tout un tas d’options qui vont permettre d’améliorer le document final. On peut par exemple ajouter une table des matières avec output: html_document: toc: true On peut également utiliser des styles prédéfinis en changeant le thème, voir https://www.datadreaming.org/post/r-markdown-theme-gallery/ output: html_document: theme: cerulean utilisant le package prettydoc (il faut l’installer), voir https://github.com/yixuan/prettydoc output: prettydoc::html_pretty: theme: cayman highlight: github utilisant le package rmdformats (à installer aussi), voir https://github.com/juba/rmdformats output: rmdformats::readthedown: highlight: kate "],
["objetsR.html", "Chapitre 2 Les objets R 2.1 Création d’objets 2.2 Vecteur 2.3 Matrices 2.4 Listes 2.5 Dataframe 2.6 Quelques fonctions importantes 2.7 Exercices complémentaires", " Chapitre 2 Les objets R On commencera par créer un répertoire dans lequel on mettra tous les fichiers du tutoriel. On pourra créer un projet avec Rstudio dans lequel on placera ces fichiers (File -&gt; New Project…). Par défaut, le répertoire de travail se situera dans le répertoire de ce projet. On peut le vérifier avec la commande &gt; getwd() La commande setwd permet de changer le répertoire de travail si besoin. On peut aussi le faire en utilisant le menu Session -&gt; Set Working directory -&gt; Choose directory…. 2.1 Création d’objets 2.1.1 Numérique On crée un objet R en assignant une valeur (ou un caractère, vecteur…) avec les opérateurs &lt;-, -&gt;, = &gt; b &lt;- 41.3 # assigne la valeur 41.3 à l&#39;objet b &gt; x &lt;- b # b est assigné à x &gt; x = b # b est assigné à x &gt; b -&gt; x # b est assigné à x &gt; is.numeric(b) [1] TRUE &gt; mode(b) [1] &quot;numeric&quot; 2.1.2 Caractère Les chaines de caractères sont définies avec des guillemets : \"chaine\", par exemple &gt; x &lt;- &quot;La mort&quot; &gt; y &lt;- &quot;aux trousses&quot; &gt; paste(x,y) [1] &quot;La mort aux trousses&quot; &gt; is.character(x) [1] TRUE 2.1.3 Facteur L’objet facteur est très utile pour travailler avec des variables qualitatives. Cet objet permet d’identifier les modalités prisent par la variable et de travailler dessus, en changeant par exemple le nom d’une modalité : &gt; V1 &lt;- factor(c(&quot;less20years&quot;,&quot;more50years&quot;,&quot;less20years&quot;,&quot;more50years&quot;,&quot;less20years&quot;)) &gt; V1 [1] less20years more50years less20years more50years less20years Levels: less20years more50years &gt; levels(V1) [1] &quot;less20years&quot; &quot;more50years&quot; &gt; levels(V1) &lt;- c(&quot;Young&quot;,&quot;Old&quot;) &gt; V1 [1] Young Old Young Old Young Levels: Young Old 2.1.4 Logique (Booléen) &gt; x &lt;- TRUE &gt; is.logical(x) [1] TRUE &gt; mode(x) [1] &quot;logical&quot; &gt; a &lt;- 1 &gt; a==1 [1] TRUE &gt; a!=1 [1] FALSE &gt; a&lt;0 [1] FALSE &gt; a&gt;0 [1] TRUE 2.2 Vecteur On peut définir un vecteur de plusieurs façons : fonction collect c &gt; x &lt;- c(1.2,5,9,11) &gt; x [1] 1.2 5.0 9.0 11.0 opérateur séquence : &gt; 1:5 [1] 1 2 3 4 5 fonction séquence seq &gt; seq(1,10,by=2) [1] 1 3 5 7 9 &gt; seq(0,1,length=10) [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667 [8] 0.7777778 0.8888889 1.0000000 fonction rep &gt; rep(1,4) [1] 1 1 1 1 &gt; rep(c(1,3),each=3) [1] 1 1 1 3 3 3 On peut aussi créer des vecteurs caractère ou logique &gt; x &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) &gt; x &lt;- rep(&quot;A&quot;,5) &gt; paste(&quot;X&quot;,1:5,sep=&quot;-&quot;) [1] &quot;X-1&quot; &quot;X-2&quot; &quot;X-3&quot; &quot;X-4&quot; &quot;X-5&quot; &gt; substr(&quot;statistician&quot;,5,9) [1] &quot;istic&quot; 2.2.1 Sélectionner une partie d’un vecteur La sélection s’effectue à l’aide de crochets [ ] &gt; x &lt;- c(-4,-3,1,3,5,8,0) &gt; x[2] [1] -3 &gt; x[c(2,5)] [1] -3 5 &gt; x&gt;0 [1] FALSE FALSE TRUE TRUE TRUE TRUE FALSE &gt; x[x&gt;0] [1] 1 3 5 8 2.2.2 Opérations sur les vecteurs On peut facilement additionner, multiplier des vecteurs : &gt; x &lt;- seq(-10,10,by=2) &gt; y &lt;- 1:length(x) &gt; x+y [1] -9 -6 -3 0 3 6 9 12 15 18 21 &gt; x*y [1] -10 -16 -18 -16 -10 0 14 32 54 80 110 &gt; z &lt;- x&gt;0 &gt; x*z [1] 0 0 0 0 0 0 2 4 6 8 10 Exercice 2.1 (Manipulation de vecteurs) Calculer la moyenne, la somme, la médiane et la variance du vecteur (1,3,8,9,11). &gt; x &lt;- c(1,3,8,9,11) &gt; mean(x) [1] 6.4 &gt; sum(x) [1] 32 &gt; median(x) [1] 8 &gt; var(x) [1] 17.8 Créer les vecteurs suivants en utilisant la fonction rep. vec1 = 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 vec2 = 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 vec3 = 1 1 2 2 2 3 3 3 3 4 4 4 4 4 &gt; rep(1:5,3) [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 &gt; rep(1:5,each=3) [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 &gt; rep(1:4,2:5) [1] 1 1 2 2 2 3 3 3 3 4 4 4 4 4 Créer le vecteur suivant à l’aide de la fonction paste. vec4 = &quot;A0)&quot; &quot;A1)&quot; &quot;A2)&quot; &quot;A3)&quot; &quot;A4)&quot; &quot;A5)&quot; &quot;A6)&quot; &quot;A7)&quot; &quot;A8)&quot; &quot;A9)&quot; &quot;A10)&quot; paste(&quot;A&quot;,0:10,&quot;)&quot;,sep=&quot;&quot;) letters est un vecteur qui contient les 26 lettres de l’alphabet. Trouver le numéro de la lettre \\(q\\) (sans compter avec les mains !). On pourra utiliser la fonction which. Créer le vecteur “a1”,“b2”,\\(\\dots\\) jusqu’à \\(q\\) et son index. &gt; index_q &lt;- which(letters==&quot;q&quot;) &gt; paste(letters[1:index_q],1:index_q,sep=&quot;&quot;) [1] &quot;a1&quot; &quot;b2&quot; &quot;c3&quot; &quot;d4&quot; &quot;e5&quot; &quot;f6&quot; &quot;g7&quot; &quot;h8&quot; &quot;i9&quot; &quot;j10&quot; &quot;k11&quot; &quot;l12&quot; [13] &quot;m13&quot; &quot;n14&quot; &quot;o15&quot; &quot;p16&quot; &quot;q17&quot; 2.3 Matrices La fonction matrix permet de définir des matrices. &gt; m &lt;- matrix(1:4,ncol=2) &gt; m [,1] [,2] [1,] 1 3 [2,] 2 4 &gt; m &lt;- matrix(1:4,nrow=2) &gt; m [,1] [,2] [1,] 1 3 [2,] 2 4 &gt; m &lt;- matrix(1:4,nrow=2,byrow=TRUE) &gt; dim(m) [1] 2 2 La position d’un élement dans une matrice est indiquée par ses numéros de ligne et de colonne. Ainsi, pour séléctionner le terme de la 2ème ligne et la 1ère colonne, on utilisera &gt; m[2,1] [1] 3 On peut aussi extraire des lignes et des colonnes : &gt; m[1,] #première ligne [1] 1 2 &gt; m[,2] #deuxième colonne [1] 2 4 Il n’est pas difficile de faire les calculs usuels sur les matrices : &gt; det(m) #déterminant [1] -2 &gt; solve(m) #inverse [,1] [,2] [1,] -2.0 1.0 [2,] 1.5 -0.5 &gt; t(m) #transposé [,1] [,2] [1,] 1 3 [2,] 2 4 &gt; n &lt;- matrix(5:8,nrow=2) &gt; m+n [,1] [,2] [1,] 6 9 [2,] 9 12 &gt; m*n #attention : produit de Hadamart [,1] [,2] [1,] 5 14 [2,] 18 32 &gt; m%*%n #Produit matriciel [,1] [,2] [1,] 17 23 [2,] 39 53 &gt; eigen(m) #Décomposition en valeurs propres eigen() decomposition $values [1] 5.3722813 -0.3722813 $vectors [,1] [,2] [1,] -0.4159736 -0.8245648 [2,] -0.9093767 0.5657675 2.4 Listes Une liste est un objet hétérogène. Elle permet de stocker des objets de différents modes dans un même objet. Par exemple, on peut céer une liste qui contient un vecteur et une matrice à l’aide de &gt; mylist &lt;- list(vector=rep(1:5),mat=matrix(1:8,nrow=2)) &gt; mylist $vector [1] 1 2 3 4 5 $mat [,1] [,2] [,3] [,4] [1,] 1 3 5 7 [2,] 2 4 6 8 &gt; length(mylist) [1] 2 L’extraction s’effectue en indiquant la position de l’objet à extraire dans un double crochet [[ ]] : &gt; mylist[[1]] [1] 1 2 3 4 5 On peut aussi utiliser le nom de l’élément à extraire : &gt; mylist$mat [,1] [,2] [,3] [,4] [1,] 1 3 5 7 [2,] 2 4 6 8 &gt; mylist[[&quot;mat&quot;]] [,1] [,2] [,3] [,4] [1,] 1 3 5 7 [2,] 2 4 6 8 2.5 Dataframe Les dataframes sont des listes particulières dont les composantes ont la même longueur, mais potentiellement des modes différents. C’est l’objet généralement utilisé pour les tableaux de données (qui contiennent souvent des variables quantitatives et qualitatives). Par exemple, &gt; name &lt;- c(&quot;Paul&quot;,&quot;Mary&quot;,&quot;Steven&quot;,&quot;Charlotte&quot;,&quot;Peter&quot;) &gt; sex &lt;- factor(c(&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;)) &gt; size &lt;- c(180,165,168,170,175) &gt; data &lt;- data.frame(name,sex,size) &gt; summary(data) name sex size Length:5 F:2 Min. :165.0 Class :character M:3 1st Qu.:168.0 Mode :character Median :170.0 Mean :171.6 3rd Qu.:175.0 Max. :180.0 On observe que name est un vecteur de caractères, sex un facteur et size un vecteur numérique. L’extraction est similaire aux matrices et aux listes : &gt; data[2,3] [1] 165 &gt; data[,2] [1] M F M F M Levels: F M &gt; data$sex [1] M F M F M Levels: F M 2.6 Quelques fonctions importantes summary produit un résumé d’un objet &gt; summary(data) name sex size Length:5 F:2 Min. :165.0 Class :character M:3 1st Qu.:168.0 Mode :character Median :170.0 Mean :171.6 3rd Qu.:175.0 Max. :180.0 &gt; summary(1:10) Min. 1st Qu. Median Mean 3rd Qu. Max. 1.00 3.25 5.50 5.50 7.75 10.00 mean, sum, median, var, min, max… (facile à comprendre) sort, order &gt; x &lt;- c(1,8,5,4) &gt; sort(x) [1] 1 4 5 8 &gt; order(x) [1] 1 4 3 2 apply applique une fonction f aux lignes ou colonnes d’une matrice ou dataframe &gt; V1 &lt;- 1:10 &gt; V2 &lt;- seq(-20,25,length=10) &gt; df &lt;- data.frame(V1,V2) &gt; apply(df,1,mean) [1] -9.5 -6.5 -3.5 -0.5 2.5 5.5 8.5 11.5 14.5 17.5 &gt; apply(df,2,sum) V1 V2 55 25 2.7 Exercices complémentaires Exercice 2.2 (Manipulation de matrices) Créer la matrice suivante que l’on appellera mat (on pourra utiliser les fonctions rownames et colnames) : column 1 column 2 column 3 column 4 row-1 1 5 5 0 row-2 0 5 6 1 row-3 3 0 3 3 row-4 4 4 4 2 &gt; mat &lt;- matrix(c(1,0,3,4,5,5,0,4,5,6,3,4,0,1,3,2),ncol=4) &gt; rownames(mat) &lt;- paste(&quot;row-&quot;,1:4,sep=&quot;&quot;) &gt; colnames(mat) &lt;- paste(&quot;column &quot;,1:4) &gt; mat column 1 column 2 column 3 column 4 row-1 1 5 5 0 row-2 0 5 6 1 row-3 3 0 3 3 row-4 4 4 4 2 Créer un vecteur qui contient la diagonal de mat. &gt; diag(mat) [1] 1 5 3 2 Créer une matrice qui contient les 2 premières lignes de mat. &gt; mat[1:2,] column 1 column 2 column 3 column 4 row-1 1 5 5 0 row-2 0 5 6 1 Créer une matrice qui contient les 2 dernières colonnes de mat. &gt; mat[,3:4] column 3 column 4 row-1 5 0 row-2 6 1 row-3 3 3 row-4 4 2 Calculer le déterminant et l’inverse de mat. &gt; det(mat) [1] 60 &gt; solve(mat) row-1 row-2 row-3 row-4 column 1 0.5 -0.5 0.1666667 -1.665335e-16 column 2 -0.6 0.4 -0.4666667 5.000000e-01 column 3 0.7 -0.3 0.4333333 -5.000000e-01 column 4 -1.2 0.8 -0.2666667 5.000000e-01 Exercice 2.3 (Manipulation simples sur un jeu de données) On considère le jeu de données iris disponible sous R : &gt; data(iris) &gt; head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 6 5.4 3.9 1.7 0.4 setosa Calculer les moyennes et variances des variables Sepal.Width et Petal.Length. &gt; mean(iris$Sepal.Width) [1] 3.057333 &gt; mean(iris$Petal.Length) [1] 3.758 &gt; var(iris$Sepal.Width) [1] 0.1899794 &gt; var(iris$Petal.Length) [1] 3.116278 Créer un sous jeu de données qui contient uniquement les iris de l’espèce versicolor. On appellera ce tableau iris2. &gt; test &lt;- iris$Species==&quot;versicolor&quot; &gt; iris2 &lt;- iris[test,] Ordonner les individus dans iris2 par valeurs décroissantes de la variable Sepal.Length (on pourra utiliser la fonction order). &gt; ord &lt;- order(iris2$Sepal.Length,decreasing=TRUE) &gt; iris3 &lt;- iris2[ord,] Calculer les valeurs moyennes de Sepal.Length pour chaque espèce. &gt; mean(iris[iris$Species==&quot;versicolor&quot;,&quot;Sepal.Length&quot;]) [1] 5.936 &gt; mean(iris[iris$Species==&quot;virginica&quot;,&quot;Sepal.Length&quot;]) [1] 6.588 &gt; mean(iris[iris$Species==&quot;setosa&quot;,&quot;Sepal.Length&quot;]) [1] 5.006 Ajouter une variable (qu’on appellera sum.Petal) dans le dataframe iris qui contiendra la somme de Petal.Length et Petal.Width. &gt; iris$sum.petal &lt;- iris$Petal.Length+iris$Petal.Width &gt; head(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Species sum.petal 1 5.1 3.5 1.4 0.2 setosa 1.6 2 4.9 3.0 1.4 0.2 setosa 1.6 3 4.7 3.2 1.3 0.2 setosa 1.5 4 4.6 3.1 1.5 0.2 setosa 1.7 5 5.0 3.6 1.4 0.2 setosa 1.6 6 5.4 3.9 1.7 0.4 setosa 2.1 Exercice 2.4 (Fonction apply) Calculer les indicateurs numériques standards (moyenne, min, max, etc.) des 3 variables du jeux de données ethanol (disponible dans le package lattice). &gt; library(lattice) &gt; data(&quot;ethanol&quot;) &gt; summary(ethanol) NOx C E Min. :0.370 Min. : 7.500 Min. :0.5350 1st Qu.:0.953 1st Qu.: 8.625 1st Qu.:0.7618 Median :1.754 Median :12.000 Median :0.9320 Mean :1.957 Mean :12.034 Mean :0.9265 3rd Qu.:3.003 3rd Qu.:15.000 3rd Qu.:1.1098 Max. :4.028 Max. :18.000 Max. :1.2320 &gt; apply(ethanol,2,mean) NOx C E 1.9573750 12.0340909 0.9264773 Calculer les quartiles de chaque variables. On pourra faire un apply avec la fonction quantile. &gt; quantile(ethanol$NOx,probs=c(0.25,0.5,0.75)) 25% 50% 75% 0.9530 1.7545 3.0030 &gt; quantile(ethanol$C,probs=c(0.25,0.5,0.75)) 25% 50% 75% 8.625 12.000 15.000 &gt; quantile(ethanol$E,probs=c(0.25,0.5,0.75)) 25% 50% 75% 0.76175 0.93200 1.10975 &gt; #ou mieux &gt; apply(ethanol,2,quantile,probs=c(0.25,0.5,0.75)) NOx C E 25% 0.9530 8.625 0.76175 50% 1.7545 12.000 0.93200 75% 3.0030 15.000 1.10975 Faire de même pour les déciles. &gt; apply(ethanol,2,quantile,probs=seq(0.1,0.9,by=0.1)) NOx C E 10% 0.6000 7.5 0.6496 20% 0.8030 7.5 0.7206 30% 1.0138 9.0 0.7977 40% 1.4146 9.0 0.8636 50% 1.7545 12.0 0.9320 60% 2.0994 12.6 1.0104 70% 2.7232 15.0 1.0709 80% 3.3326 15.0 1.1404 90% 3.6329 18.0 1.1920 Exercice 2.5 (Données manquantes) On considère le jeu de données presidents &gt; data(&quot;presidents&quot;) &gt; df &lt;- matrix(presidents,ncol=4,byrow=T) Est-ce que la ligne 20 contient au moins une données manquante ? On pourra utiliser la fonction any. &gt; any(is.na(df[20,])) [1] FALSE Quelles sont les lignes de df qui contiennent au moins une donnée manquante ? On pourra utiliser la fonction which. &gt; which(apply(is.na(df),1,any)) [1] 1 4 8 28 Supprimer les lignes de df qui contiennent au moins une donnée manquante. &gt; ind_sup &lt;- which(apply(is.na(df),1,any)) &gt; df1 &lt;- df[-ind_sup,] &gt; summary(df1) V1 V2 V3 V4 Min. :28.00 Min. :24.00 Min. :24.00 Min. :23.00 1st Qu.:52.50 1st Qu.:49.00 1st Qu.:46.50 1st Qu.:44.50 Median :64.50 Median :60.50 Median :61.00 Median :55.50 Mean :60.96 Mean :56.69 Mean :56.27 Mean :53.04 3rd Qu.:71.00 3rd Qu.:64.75 3rd Qu.:66.50 3rd Qu.:61.50 Max. :80.00 Max. :83.00 Max. :79.00 Max. :78.00 On aurait aussi pu utiliser directement la fonction na.omit : &gt; df2 &lt;- na.omit(df) &gt; all(df1==df2) [1] TRUE "],
["dplyr.html", "Chapitre 3 Manipuler les données avec dplyr 3.1 Importer des données 3.2 Le package dplyr", " Chapitre 3 Manipuler les données avec dplyr Les données sont souvent le point de départ d’une étude statistique. Elles sont généralement d’abord stockées dans des fichiers (txt, xls, csv) et une des premières étapes est d’amener ces données dans R et de les affecter à un objet de type dataframe. Il est par conséquent très important connaître et maîtriser les opérations qui permettent de réaliser ces importations. Nous présentons tout d’abord quelques fonctions qui permettent de faire ces importations avant de présenter le package dplyr qui offre une syntaxe claire pour manipuler des données (correctement importées). 3.1 Importer des données Les fonction read.table et read.csv sont les fonctions standards de R pour importer des données à partir de fichiers .txt ou .csv. Il est important de bien gérer le chemin du répertoireou se trouve le fichier. On peut le spécifier explicitement ou utiliser des fonctions comme file.path : &gt; path &lt;- file.path(&quot;data/&quot;, &quot;piscines.csv&quot;) #premier : répertoire, deuxième : fichier &gt; piscines &lt;- read.csv(path) &gt; class(piscines) [1] &quot;data.frame&quot; &gt; summary(piscines) Name Address Latitude Longitude Length:20 Length:20 Min. :-27.61 Min. :152.9 Class :character Class :character 1st Qu.:-27.55 1st Qu.:153.0 Mode :character Mode :character Median :-27.49 Median :153.0 Mean :-27.49 Mean :153.0 3rd Qu.:-27.45 3rd Qu.:153.1 Max. :-27.31 Max. :153.2 Il existe plusieurs options importantes dans read.csv, notamment sep : le caractère de séparation (espace, virgule…) dec : le caractère pour le séparateur décimal (vigule, point…) header : logique pour indiquer si le nom des variables est spécifié à la première ligne du fichier row.names : vecteurs des identifiants (si besoin) na.strings : vecteur de caractères pour repérer les données manquantes. … Le package readr du tidyverse propose d’autres fonctions comme read_csv ou read_delim. Il n’y a pas de différences énormes avec les fonctions standards, les objets créés sont des tibbles et plus des dataframes (même si les tibbles sont des dataframes…). Par exemple &gt; library(readr) &gt; piscines &lt;- read_csv(&quot;data/piscines.csv&quot;) &gt; summary(piscines) Name Address Latitude Longitude Length:20 Length:20 Min. :-27.61 Min. :152.9 Class :character Class :character 1st Qu.:-27.55 1st Qu.:153.0 Mode :character Mode :character Median :-27.49 Median :153.0 Mean :-27.49 Mean :153.0 3rd Qu.:-27.45 3rd Qu.:153.1 Max. :-27.31 Max. :153.2 &gt; class(piscines) [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Enfin si on n’est pas très à l’aise avec ces fonctions, on pourra utiliser le bouton Import Dataset qui se trouve dans l’onglet Environment de RStudio. Cette manière de procéder fonctionne pour des jeux de données simples, si les bases de données contient trop de spécificités on devra souvent utiliser les fonctions avec les bonnes options. Exercice 3.1 (Importation d’un jeu de données) Importer les données qui se trouvent dans le fichier mydata.csv. On utilisera la fonction read.csv avec les options par défaut. &gt; data1 &lt;- read.csv(&quot;data/mydata.csv&quot;) &gt; summary(data1) surname.height.weight.feet_size.sex Length:3 Class :character Mode :character Importer correctement les données qui se trouvent dans le fichier mydata.csv (utiliser sep, dec et row.names). &gt; data1 &lt;- read.csv(&quot;data/mydata.csv&quot;,sep=&quot;;&quot;,dec=c(&quot;.&quot;),row.names = 1) &gt; summary(data1) height weight feet_size sex Min. :158.0 Min. :72.00 Min. :8.000 Length:3 1st Qu.:166.8 1st Qu.:75.00 1st Qu.:8.250 Class :character Median :175.5 Median :78.00 Median :8.500 Mode :character Mean :172.5 Mean :76.67 Mean :8.667 3rd Qu.:179.8 3rd Qu.:79.00 3rd Qu.:9.000 Max. :184.0 Max. :80.00 Max. :9.500 Importer les données qui se trouvent dans le fichier mydata2.csv. &gt; data2 &lt;- read.csv(&quot;data/mydata2.csv&quot;) &gt; summary(data2) height.weight.size.sex Length:4 Class :character Mode :character Ce fichier contient des données manquantes (identifiées par un point). A l’aide de na.strings, refaire l’importation en identifiant les données manquantes. &gt; data2 &lt;- read.csv(&quot;data/mydata2.csv&quot;,sep=&quot;&quot;,na.strings = &quot;.&quot;) &gt; summary(data2) height weight size sex Min. :175.5 Min. :72.00 Min. :7.00 Length:4 1st Qu.:176.8 1st Qu.:75.00 1st Qu.:7.75 Class :character Median :178.0 Median :78.00 Median :8.25 Mode :character Mean :179.2 Mean :76.67 Mean :8.25 3rd Qu.:181.0 3rd Qu.:79.00 3rd Qu.:8.75 Max. :184.0 Max. :80.00 Max. :9.50 NA&#39;s :1 NA&#39;s :1 Changer les levels de la variable sex en woman et man (on pourra utiliser la fonction levels). &gt; data22 &lt;- data2 1ère façon : &gt; levels(data2$sex) &lt;- c(&quot;woman&quot;,&quot;man&quot;) &gt; summary(data2) height weight size sex Min. :175.5 Min. :72.00 Min. :7.00 Length:4 1st Qu.:176.8 1st Qu.:75.00 1st Qu.:7.75 Class :character Median :178.0 Median :78.00 Median :8.25 Mode :character Mean :179.2 Mean :76.67 Mean :8.25 3rd Qu.:181.0 3rd Qu.:79.00 3rd Qu.:8.75 Max. :184.0 Max. :80.00 Max. :9.50 NA&#39;s :1 NA&#39;s :1 2ème façon avec recode_factor &gt; library(tidyverse) &gt; data22$sex &lt;- recode_factor(data2$sex,&quot;F&quot;=&quot;woman&quot;,&quot;M&quot;=&quot;man&quot;) &gt; summary(data22) height weight size sex Min. :175.5 Min. :72.00 Min. :7.00 woman:1 1st Qu.:176.8 1st Qu.:75.00 1st Qu.:7.75 man :3 Median :178.0 Median :78.00 Median :8.25 Mean :179.2 Mean :76.67 Mean :8.25 3rd Qu.:181.0 3rd Qu.:79.00 3rd Qu.:8.75 Max. :184.0 Max. :80.00 Max. :9.50 NA&#39;s :1 NA&#39;s :1 Exercice 3.2 (Jointure de tables) On considère les 3 jeux de données suivants, au format tibble : &gt; df1 &lt;- tibble(name=c(&quot;Mary&quot;,&quot;Peter&quot;,&quot;John&quot;,&quot;July&quot;),age=c(18,25,21,43)) &gt; df2 &lt;- tibble(name=c(&quot;Zac&quot;,&quot;Julian&quot;),age=c(23,48)) &gt; df3 &lt;- tibble(size=c(154,178,182,134,142),name1=c(&quot;Peter&quot;,&quot;Mary&quot;,&quot;July&quot;,&quot;John&quot;,&quot;stef&quot;)) &gt; df1 # A tibble: 4 x 2 name age &lt;chr&gt; &lt;dbl&gt; 1 Mary 18 2 Peter 25 3 John 21 4 July 43 &gt; df2 # A tibble: 2 x 2 name age &lt;chr&gt; &lt;dbl&gt; 1 Zac 23 2 Julian 48 &gt; df3 # A tibble: 5 x 2 size name1 &lt;dbl&gt; &lt;chr&gt; 1 154 Peter 2 178 Mary 3 182 July 4 134 John 5 142 stef On souhaite assembler ces tables en utilisant les fonctions de jointure du tidyverse (left_join, full_join par exemple). On pourra consulter la cheatsheet Data transformation with dplyr (help -&gt; cheatsheets -&gt; …). Assembler df1 avec df2 en utilisant bind_rows et calculer la moyenne de la variable age. On appellera df cette nouvelle table. &gt; df &lt;- bind_rows(df1,df2) &gt; mean(df$age) [1] 29.66667 Assembler df avec df3 en utilisant full_join. &gt; a1 &lt;- full_join(df,df3,by=c(&quot;name&quot;=&quot;name1&quot;)) &gt; a1 # A tibble: 7 x 3 name age size &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mary 18 178 2 Peter 25 154 3 John 21 134 4 July 43 182 5 Zac 23 NA 6 Julian 48 NA 7 stef NA 142 Faire la même chose avec inner_join. &gt; a2 &lt;- inner_join(df,df3,by=c(&quot;name&quot;=&quot;name1&quot;)) &gt; a2 # A tibble: 4 x 3 name age size &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mary 18 178 2 Peter 25 154 3 John 21 134 4 July 43 182 Expliquer les différences entre full_join et inner_join. inner_join retient uniquement les individus pour lesquels age et size ont été observés. full_join garde tous les individus, des NA sont ajoutées lorsque la variable n’est pas observée. 3.2 Le package dplyr dplyr est un package du tidyverse qui permet de faciliter la manipulation des données. Il propose une syntaxe claire (basée sur une grammaire) pour manipuler les données. On pourra trouver des informations ici ou sur la cheatsheet. Nous avons vu quelques opérations standards pour manipuler les données. Par exemple, on peut obtenir les Longitude et Latitude des piscines ayant une Longitude supérieure à 153 avec &gt; piscines[piscines$Longitude&gt;153,c(&quot;Longitude&quot;,&quot;Latitude&quot;)] # A tibble: 16 x 2 Longitude Latitude &lt;dbl&gt; &lt;dbl&gt; 1 153. -27.6 2 153. -27.5 3 153. -27.4 4 153. -27.5 5 153. -27.5 6 153. -27.5 7 153. -27.6 8 153. -27.5 9 153. -27.5 10 153. -27.5 11 153. -27.5 12 153. -27.4 13 153. -27.6 14 153. -27.3 15 153. -27.5 16 153. -27.5 dplyr propose de faire la même chose avec une syntaxe plus claire &gt; library(tidyverse) #ou library(dplyr) &gt; piscines %&gt;% select(Longitude,Latitude) %&gt;% filter(Longitude&gt;153) # A tibble: 16 x 2 Longitude Latitude &lt;dbl&gt; &lt;dbl&gt; 1 153. -27.6 2 153. -27.5 3 153. -27.4 4 153. -27.5 5 153. -27.5 6 153. -27.5 7 153. -27.6 8 153. -27.5 9 153. -27.5 10 153. -27.5 11 153. -27.5 12 153. -27.4 13 153. -27.6 14 153. -27.3 15 153. -27.5 16 153. -27.5 Le code est plus efficace et facile à lire. dplyr propose une grammaire dont les principaux verbes sont : select() : selectionner des colonnes (variables) filter() : filter des lignes (individus) arrange() : ordonner des lignes mutate() : créer des nouvelles colonnes (nouvelles variables) summarise() : calculer des résumés numériques (ou résumés statistiques) group_by() : effectuer des opérations pour des groupes d’individus Nous les présentons dans la partie suivante. 3.2.1 Les principaux verbres dplyr Le verbe select() Il permet de sélectionner des variables (colonnes) : &gt; select(df, VAR1, VAR2, ...) Par exemple, &gt; coord &lt;- select(piscines, Latitude, Longitude) &gt; head(piscines, n=2) # A tibble: 2 x 4 Name Address Latitude Longitude &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Acacia Ridge Leisure Cent… 1391 Beaudesert Road, Acacia Ri… -27.6 153. 2 Bellbowrie Pool Sugarwood Street, Bellbowrie -27.6 153. &gt; head(coord, n=2) # A tibble: 2 x 2 Latitude Longitude &lt;dbl&gt; &lt;dbl&gt; 1 -27.6 153. 2 -27.6 153. On peut utiliser les helper functions (begins_with, end_with, contains, matches) pour des sélections plus précises basées sur le nom des variables. &gt; coord &lt;- select(piscines, ends_with(&quot;tude&quot;)) &gt; head(coord, n=2) # A tibble: 2 x 2 Latitude Longitude &lt;dbl&gt; &lt;dbl&gt; 1 -27.6 153. 2 -27.6 153. Le verbe mutate() Il permet de créer des nouvelles variables &gt; mutate(df, NEW.VAR = expression(VAR1, VAR2, ...)) Par exemple &gt; df &lt;- mutate(piscines, phrase=paste(&quot;Swimming pool&quot;, Name, &quot;is located at the address&quot;, Address)) &gt; select(df,phrase) # A tibble: 20 x 1 phrase &lt;chr&gt; 1 Swimming pool Acacia Ridge Leisure Centre is located at the address 1391 Bea… 2 Swimming pool Bellbowrie Pool is located at the address Sugarwood Street, Be… 3 Swimming pool Carole Park is located at the address Cnr Boundary Road and Wa… 4 Swimming pool Centenary Pool (inner City) is located at the address 400 Greg… 5 Swimming pool Chermside Pool is located at the address 375 Hamilton Road, Ch… 6 Swimming pool Colmslie Pool (Morningside) is located at the address 400 Lytt… 7 Swimming pool Spring Hill Baths (inner City) is located at the address 14 To… 8 Swimming pool Dunlop Park Pool (Corinda) is located at the address 794 Oxley… 9 Swimming pool Fortitude Valley Pool is located at the address 432 Wickham St… 10 Swimming pool Hibiscus Sports Complex (upper MtGravatt) is located at the ad… 11 Swimming pool Ithaca Pool ( Paddington) is located at the address 131 Caxton… 12 Swimming pool Jindalee Pool is located at the address 11 Yallambee Road, Jin… 13 Swimming pool Manly Pool is located at the address 1 Fairlead Crescent, Manly 14 Swimming pool Mt Gravatt East Aquatic Centre is located at the address Cnr w… 15 Swimming pool Musgrave Park Pool (South Brisbane) is located at the address … 16 Swimming pool Newmarket Pool is located at the address 71 Alderson Stret, Ne… 17 Swimming pool Runcorn Pool is located at the address 37 Bonemill Road, Runco… 18 Swimming pool Sandgate Pool is located at the address 231 Flinders Parade, S… 19 Swimming pool Langlands Parks Pool (Stones Corner) is located at the address… 20 Swimming pool Yeronga Park Pool is located at the address 81 School Road, Ye… On peut également créer plusieurs variables avec un seul mutate : &gt; mutate(piscines, + phrase = paste(&quot;Swimming pool&quot;, Name, &quot;is located at the address&quot;, Address), + unused = Longitude + Latitude + ) # A tibble: 20 x 6 Name Address Latitude Longitude phrase unused &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Acacia Ridge… 1391 Beaudeser… -27.6 153. Swimming pool Acacia… 125. 2 Bellbowrie P… Sugarwood Stre… -27.6 153. Swimming pool Bellbo… 125. 3 Carole Park Cnr Boundary R… -27.6 153. Swimming pool Carole… 125. 4 Centenary Po… 400 Gregory Te… -27.5 153. Swimming pool Centen… 126. 5 Chermside Po… 375 Hamilton R… -27.4 153. Swimming pool Cherms… 126. 6 Colmslie Poo… 400 Lytton Roa… -27.5 153. Swimming pool Colmsl… 126. 7 Spring Hill … 14 Torrington … -27.5 153. Swimming pool Spring… 126. 8 Dunlop Park … 794 Oxley Road… -27.5 153. Swimming pool Dunlop… 125. 9 Fortitude Va… 432 Wickham St… -27.5 153. Swimming pool Fortit… 126. 10 Hibiscus Spo… 90 Klumpp Road… -27.6 153. Swimming pool Hibisc… 126. 11 Ithaca Pool … 131 Caxton Str… -27.5 153. Swimming pool Ithaca… 126. 12 Jindalee Pool 11 Yallambee R… -27.5 153. Swimming pool Jindal… 125. 13 Manly Pool 1 Fairlead Cre… -27.5 153. Swimming pool Manly … 126. 14 Mt Gravatt E… Cnr wecker Roa… -27.5 153. Swimming pool Mt Gra… 126. 15 Musgrave Par… 100 Edmonstone… -27.5 153. Swimming pool Musgra… 126. 16 Newmarket Po… 71 Alderson St… -27.4 153. Swimming pool Newmar… 126. 17 Runcorn Pool 37 Bonemill Ro… -27.6 153. Swimming pool Runcor… 125. 18 Sandgate Pool 231 Flinders P… -27.3 153. Swimming pool Sandga… 126. 19 Langlands Pa… 5 Panitya Stre… -27.5 153. Swimming pool Langla… 126. 20 Yeronga Park… 81 School Road… -27.5 153. Swimming pool Yerong… 125. Le verbe filter() Il permet de sélectionner des individus (lignes) : &gt; filter(df, TEST) Par exemple &gt; p1 &lt;- filter(piscines, Longitude&gt;153.02) &gt; select(p1,Longitude) # A tibble: 12 x 1 Longitude &lt;dbl&gt; 1 153. 2 153. 3 153. 4 153. 5 153. 6 153. 7 153. 8 153. 9 153. 10 153. 11 153. 12 153. ou (on sélectionne les piscines dont le nom contient Pool) &gt; df &lt;- filter(piscines, !grepl(&quot;Pool&quot;, Name)) &gt; select(df,Name) # A tibble: 5 x 1 Name &lt;chr&gt; 1 Acacia Ridge Leisure Centre 2 Carole Park 3 Spring Hill Baths (inner City) 4 Hibiscus Sports Complex (upper MtGravatt) 5 Mt Gravatt East Aquatic Centre ou (on sélectionne les piscines avec une longitude plus grande que 153.02 ou une latitude plus petite que -27.488) &gt; p2 &lt;- filter(piscines, Longitude&gt;153.02 | Latitude &lt; -27.488) &gt; select(p2, Longitude, Latitude) # A tibble: 17 x 2 Longitude Latitude &lt;dbl&gt; &lt;dbl&gt; 1 153. -27.6 2 153. -27.6 3 153. -27.6 4 153. -27.5 5 153. -27.4 6 153. -27.5 7 153. -27.5 8 153. -27.5 9 153. -27.5 10 153. -27.6 11 153. -27.5 12 153. -27.5 13 153. -27.5 14 153. -27.6 15 153. -27.3 16 153. -27.5 17 153. -27.5 On peut également utiliser la fonction slice pour choisir des individus à partir de leurs indices : &gt; slice(piscines,5:8) # A tibble: 4 x 4 Name Address Latitude Longitude &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Chermside Pool 375 Hamilton Road, Chermside -27.4 153. 2 Colmslie Pool (Morningside) 400 Lytton Road, Morningside -27.5 153. 3 Spring Hill Baths (inner Ci… 14 Torrington Street, Springh… -27.5 153. 4 Dunlop Park Pool (Corinda) 794 Oxley Road, Corinda -27.5 153. Le verbe arrange() Il permet d’ordonner les individus en fonction d’une variable &gt; arrange(df, VAR) #tri croissant ou &gt; arrange(df, desc(VAR)) #tri décroissant Par exemple &gt; arrange(piscines, Longitude) # A tibble: 20 x 4 Name Address Latitude Longitude &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Bellbowrie Pool Sugarwood Street, Bellbowrie -27.6 153. 2 Carole Park Cnr Boundary Road and Waterf… -27.6 153. 3 Jindalee Pool 11 Yallambee Road, Jindalee -27.5 153. 4 Dunlop Park Pool (Corinda) 794 Oxley Road, Corinda -27.5 153. 5 Newmarket Pool 71 Alderson Stret, Newmarket -27.4 153. 6 Ithaca Pool ( Paddington) 131 Caxton Street, Paddington -27.5 153. 7 Musgrave Park Pool (South B… 100 Edmonstone Street, South… -27.5 153. 8 Yeronga Park Pool 81 School Road, Yeronga -27.5 153. 9 Spring Hill Baths (inner Ci… 14 Torrington Street, Spring… -27.5 153. 10 Centenary Pool (inner City) 400 Gregory Terrace, Spring … -27.5 153. 11 Acacia Ridge Leisure Centre 1391 Beaudesert Road, Acacia… -27.6 153. 12 Chermside Pool 375 Hamilton Road, Chermside -27.4 153. 13 Fortitude Valley Pool 432 Wickham Street, Fortitud… -27.5 153. 14 Langlands Parks Pool (Stone… 5 Panitya Street, Stones Cor… -27.5 153. 15 Sandgate Pool 231 Flinders Parade, Sandgate -27.3 153. 16 Hibiscus Sports Complex (up… 90 Klumpp Road, Upper Mount … -27.6 153. 17 Runcorn Pool 37 Bonemill Road, Runcorn -27.6 153. 18 Colmslie Pool (Morningside) 400 Lytton Road, Morningside -27.5 153. 19 Mt Gravatt East Aquatic Cen… Cnr wecker Road and Newnham … -27.5 153. 20 Manly Pool 1 Fairlead Crescent, Manly -27.5 153. ou &gt; arrange(piscines, desc(Longitude)) # A tibble: 20 x 4 Name Address Latitude Longitude &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Manly Pool 1 Fairlead Crescent, Manly -27.5 153. 2 Mt Gravatt East Aquatic Cen… Cnr wecker Road and Newnham … -27.5 153. 3 Colmslie Pool (Morningside) 400 Lytton Road, Morningside -27.5 153. 4 Runcorn Pool 37 Bonemill Road, Runcorn -27.6 153. 5 Hibiscus Sports Complex (up… 90 Klumpp Road, Upper Mount … -27.6 153. 6 Sandgate Pool 231 Flinders Parade, Sandgate -27.3 153. 7 Langlands Parks Pool (Stone… 5 Panitya Street, Stones Cor… -27.5 153. 8 Fortitude Valley Pool 432 Wickham Street, Fortitud… -27.5 153. 9 Chermside Pool 375 Hamilton Road, Chermside -27.4 153. 10 Acacia Ridge Leisure Centre 1391 Beaudesert Road, Acacia… -27.6 153. 11 Centenary Pool (inner City) 400 Gregory Terrace, Spring … -27.5 153. 12 Spring Hill Baths (inner Ci… 14 Torrington Street, Spring… -27.5 153. 13 Yeronga Park Pool 81 School Road, Yeronga -27.5 153. 14 Musgrave Park Pool (South B… 100 Edmonstone Street, South… -27.5 153. 15 Ithaca Pool ( Paddington) 131 Caxton Street, Paddington -27.5 153. 16 Newmarket Pool 71 Alderson Stret, Newmarket -27.4 153. 17 Dunlop Park Pool (Corinda) 794 Oxley Road, Corinda -27.5 153. 18 Jindalee Pool 11 Yallambee Road, Jindalee -27.5 153. 19 Carole Park Cnr Boundary Road and Waterf… -27.6 153. 20 Bellbowrie Pool Sugarwood Street, Bellbowrie -27.6 153. 3.2.2 Les verbes summarize et groub_by Les verbes précédents permettent de manipuler les données en sélectionnant des individus ou variables essentiellement. Ces deux nouveaux verbes vont permettre de calculer des indicateurs statistiques sur un jeu de données. Le verbe summarize (ou summarise) Il permet de créer des nouveaux jeux de données qui contiennent des résumés statistiques du jeu de données initial comme la moyenne, variance, médiane de variables. Par exemple &gt; summarise(piscines, + mean_long = mean(Longitude), + med_lat = median(Latitude), + min_lat = min(Latitude), + sum_long = sum(Longitude) + ) # A tibble: 1 x 4 mean_long med_lat min_lat sum_long &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 153. -27.5 -27.6 3061. dplyr contient également les fonction suivantes (souvent utilisées en statistique) : n() : nombre de lignes (individus d’un jeu de données). n_distinct() : nombre d’éléments distincts dans un vecteur. fisrt() et last() : premier et dernier élément d’un vecteur. Par exemple, on obtient le nombre de piscines dans le jeu de données, et la longitude de la dernière piscine avec &gt; summarise(piscines,n()) # A tibble: 1 x 1 `n()` &lt;int&gt; 1 20 &gt; summarise(piscines,last(Longitude)) # A tibble: 1 x 1 `last(Longitude)` &lt;dbl&gt; 1 153. On peut aussi utiliser summarise_all, summarise_at qui vont permettre de répéter les mêmes opérations sur plusieurs variables. Par exemple &gt; summarise_at(piscines,3:4,mean) # A tibble: 1 x 2 Latitude Longitude &lt;dbl&gt; &lt;dbl&gt; 1 -27.5 153. Regrouper des données avec ‘Group_by’ group_by permet d’appliquer une ou des opérations à des groupes de données (ou d’individus). Par exemple, imaginons que l’on souhaite calculer les longitudes moyennes des piscines scindées en 2 groupes : faible et large latitude. On créé d’abord une variable lat_dis qui permet d’identifier les latitudes (faible ou large) : &gt; lat_mean &lt;- piscines %&gt;% summarise(mean(Latitude)) &gt; pisc1 &lt;- piscines %&gt;% mutate(lat_dis=factor(Latitude&gt;as.numeric(lat_mean))) &gt; levels(pisc1$lat_dis) &lt;- c(&quot;Low&quot;,&quot;High&quot;) Il reste maintenant à utiliser group_by pour obtenir les longitudes moyennes des 2 groupes : &gt; summarise(group_by(pisc1,lat_dis),mean_long=mean(Longitude)) # A tibble: 2 x 2 lat_dis mean_long &lt;fct&gt; &lt;dbl&gt; 1 Low 153. 2 High 153. 3.2.3 Assembler des verbes avec l’opérateur de chainage %&gt;% Un des principaux intérêts de dplyr est bien entendu d’utiliser plusieurs verbes pour arriver au résultat souhaité. C’est ce qui est fait plus haut et nous observons que la syntaxe n’est pas facile à lire. Le package propose un opérateur de chainage ou pipe opérateur qui permet de rentre cette syntaxe plus lisible. Cet opérateur consiste à décomposer le code étape par étape et à relier ces étapes par le symbole %&gt;%. On peut par exemple réécrire l’exemple précédent avec : Le jeu de données &gt; pisc1 Étape group_by &gt; pisc1 %&gt;% group_by(lat_dis) Étape summarise &gt; pisc1 %&gt;% group_by(lat_dis) %&gt;% summarise(mean_long=mean(Longitude)) # A tibble: 2 x 2 lat_dis mean_long &lt;fct&gt; &lt;dbl&gt; 1 Low 153. 2 High 153. qui donne le résultat souhaité. Cet opérateur peut être utilisé pour toutes les fonctions R. Il revient à considérer comme premier argument du terme à droite du pipe le terme à gauche de ce dernier. Par exemple &gt; mean(1:10) [1] 5.5 &gt; 1:10 %&gt;% mean() [1] 5.5 Il est recommandé d’utiliser cet opérateur lorsque on chaîne les verbes dplyr, la syntaxe est beaucoup plus claire. 3.2.4 Quelques exercices Exercice 3.3 (Dplyr sur les iris de Fisher) On considère le jeu de données iris &gt; iris &lt;- iris %&gt;% as_tibble() Répondre aux questions suivantes en utilisant les verbes dplyr et l’opérateur %&gt;%. Sélectionner les variables Petal.Width et Species. &gt; iris %&gt;% select(Petal.Width,Species) # A tibble: 150 x 2 Petal.Width Species &lt;dbl&gt; &lt;fct&gt; 1 0.2 setosa 2 0.2 setosa 3 0.2 setosa 4 0.2 setosa 5 0.2 setosa 6 0.4 setosa 7 0.3 setosa 8 0.2 setosa 9 0.2 setosa 10 0.1 setosa # … with 140 more rows Construire une table qui contient uniquement les iris d’espèce versicolor ou virginica (on pourra utiliser le symbole | pour la condition ou). &gt; iris %&gt;% filter(Species==&quot;versicolor&quot; | Species==&quot;virginica&quot;) # A tibble: 100 x 6 Sepal.Length Sepal.Width Petal.Length Petal.Width Species sum.petal &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; 1 7 3.2 4.7 1.4 versicolor 6.1 2 6.4 3.2 4.5 1.5 versicolor 6 3 6.9 3.1 4.9 1.5 versicolor 6.4 4 5.5 2.3 4 1.3 versicolor 5.3 5 6.5 2.8 4.6 1.5 versicolor 6.1 6 5.7 2.8 4.5 1.3 versicolor 5.8 7 6.3 3.3 4.7 1.6 versicolor 6.3 8 4.9 2.4 3.3 1 versicolor 4.3 9 6.6 2.9 4.6 1.3 versicolor 5.90 10 5.2 2.7 3.9 1.4 versicolor 5.3 # … with 90 more rows Calculer le nombre d’iris de l’espèce setosa en utilisant summarise. &gt; iris %&gt;% filter(Species==&quot;setosa&quot;) %&gt;% summarise(n()) # A tibble: 1 x 1 `n()` &lt;int&gt; 1 50 Calculer la moyenne de la variable Petal Width pour les iris de l’espèce versicolor. &gt; iris %&gt;% filter(Species==&quot;versicolor&quot;) %&gt;% + summarise(Mean_PW=mean(Petal.Width)) # A tibble: 1 x 1 Mean_PW &lt;dbl&gt; 1 1.33 Ajouter dans le jeu de données la variable Sum_Petal qui correspond à la somme de Petal.Width et Sepal.Width. &gt; iris1 &lt;- iris &gt; iris1 %&gt;% mutate(Sum_Petal=Petal.Width+Sepal.Width) # A tibble: 150 x 7 Sepal.Length Sepal.Width Petal.Length Petal.Width Species sum.petal Sum_Petal &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 5.1 3.5 1.4 0.2 setosa 1.60 3.7 2 4.9 3 1.4 0.2 setosa 1.60 3.2 3 4.7 3.2 1.3 0.2 setosa 1.5 3.4 4 4.6 3.1 1.5 0.2 setosa 1.7 3.3 5 5 3.6 1.4 0.2 setosa 1.60 3.8 6 5.4 3.9 1.7 0.4 setosa 2.1 4.3 7 4.6 3.4 1.4 0.3 setosa 1.7 3.7 8 5 3.4 1.5 0.2 setosa 1.7 3.6 9 4.4 2.9 1.4 0.2 setosa 1.60 3.1 10 4.9 3.1 1.5 0.1 setosa 1.6 3.2 # … with 140 more rows Calculer la moyenne et la variance de la variable Sepal.Length pour chaque espèce (on pourra utiliser group_by). &gt; iris %&gt;% group_by(Species) %&gt;% + summarise(mean_PL=mean(Petal.Length),var_PL=var(Petal.Length)) %&gt;% + mutate(var_PL=round(var_PL,3)) # A tibble: 3 x 3 Species mean_PL var_PL &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 setosa 1.46 0.03 2 versicolor 4.26 0.221 3 virginica 5.55 0.305 Exercice 3.4 (Trafic aérien aux USA) On considère la table hflights qui contient des informations sur les vols au départ des aéroports Houston airports IAH (George Bush Intercontinental) et HOU (Houston Hobby): &gt; library(hflights) &gt; hflights &lt;- as_tibble(hflights) La variable Unique Carrier renseigne sur la compagnie du vol. On recode cette variable afin que la compagnie soit plus explicite : &gt; lut1 &lt;- c(&quot;AA&quot; = &quot;American&quot;, &quot;AS&quot; = &quot;Alaska&quot;, &quot;B6&quot; = &quot;JetBlue&quot;, &quot;CO&quot; = &quot;Continental&quot;, + &quot;DL&quot; = &quot;Delta&quot;, &quot;OO&quot; = &quot;SkyWest&quot;, &quot;UA&quot; = &quot;United&quot;, &quot;US&quot; = &quot;US_Airways&quot;, + &quot;WN&quot; = &quot;Southwest&quot;, &quot;EV&quot; = &quot;Atlantic_Southeast&quot;, &quot;F9&quot; = &quot;Frontier&quot;, + &quot;FL&quot; = &quot;AirTran&quot;, &quot;MQ&quot; = &quot;American_Eagle&quot;, &quot;XE&quot; = &quot;ExpressJet&quot;, &quot;YV&quot; = &quot;Mesa&quot;) On fait de même pour la variable CancellationCode : &gt; lut2 &lt;- c(&quot;A&quot; = &quot;carrier&quot;, &quot;B&quot; = &quot;weather&quot;, &quot;C&quot; = &quot;FFA&quot;, &quot;D&quot; = &quot;security&quot;, &quot;E&quot; = &quot;not cancelled&quot;) On effectue maintenant les changements dans la table pour obtenir une nouvelle version de hflights : &gt; hflights1 &lt;- hflights &gt; hflights1$UniqueCarrier &lt;- lut1[hflights1$UniqueCarrier] &gt; hflights1$CancellationCode[hflights1$CancellationCode==&quot;&quot;] &lt;- &quot;Z&quot; &gt; hflights1$CancellationCode &lt;- lut2[hflights1$CancellationCode] A partir de maintenant, on travaille avec hflights1. Sélectionner les variables qui se situent entre Origin et Cancelled de différentes façons. &gt; ind &lt;- match(c(&quot;Origin&quot;,&quot;Cancelled&quot;),names(hflights1)) &gt; hflights1 %&gt;% select(seq(ind[1],ind[2])) # A tibble: 227,496 x 6 Origin Dest Distance TaxiIn TaxiOut Cancelled &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 IAH DFW 224 7 13 0 2 IAH DFW 224 6 9 0 3 IAH DFW 224 5 17 0 4 IAH DFW 224 9 22 0 5 IAH DFW 224 9 9 0 6 IAH DFW 224 6 13 0 7 IAH DFW 224 12 15 0 8 IAH DFW 224 7 12 0 9 IAH DFW 224 8 22 0 10 IAH DFW 224 6 19 0 # … with 227,486 more rows &gt; #ou &gt; hflights1 %&gt;% select(Origin:Cancelled) # A tibble: 227,496 x 6 Origin Dest Distance TaxiIn TaxiOut Cancelled &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 IAH DFW 224 7 13 0 2 IAH DFW 224 6 9 0 3 IAH DFW 224 5 17 0 4 IAH DFW 224 9 22 0 5 IAH DFW 224 9 9 0 6 IAH DFW 224 6 13 0 7 IAH DFW 224 12 15 0 8 IAH DFW 224 7 12 0 9 IAH DFW 224 8 22 0 10 IAH DFW 224 6 19 0 # … with 227,486 more rows Sélectionner les variables DepTime, ArrTime, ActualElapsedTime, AirTime, ArrDelay and DepDelay. On pourra remarquer que toutes ces variables contiennent les chaines de caractère Time et Delay et utiliser la helper function contains(). &gt; hflights1 %&gt;% select(contains(&quot;Time&quot;),contains(&quot;Delay&quot;)) # A tibble: 227,496 x 6 DepTime ArrTime ActualElapsedTime AirTime ArrDelay DepDelay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 1400 1500 60 40 -10 0 2 1401 1501 60 45 -9 1 3 1352 1502 70 48 -8 -8 4 1403 1513 70 39 3 3 5 1405 1507 62 44 -3 5 6 1359 1503 64 45 -7 -1 7 1359 1509 70 43 -1 -1 8 1355 1454 59 40 -16 -5 9 1443 1554 71 41 44 43 10 1443 1553 70 45 43 43 # … with 227,486 more rows Ajouter une variable ActualGroundTime qui correspond à ActualElapsedTime moins AirTime. &gt; hflights2 &lt;- hflights1 %&gt;% mutate(ActualGroundTime=ActualElapsedTime-AirTime) &gt; head(hflights2) # A tibble: 6 x 22 Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 2011 1 1 6 1400 1500 American 428 2 2011 1 2 7 1401 1501 American 428 3 2011 1 3 1 1352 1502 American 428 4 2011 1 4 2 1403 1513 American 428 5 2011 1 5 3 1405 1507 American 428 6 2011 1 6 4 1359 1503 American 428 # … with 14 more variables: TailNum &lt;chr&gt;, ActualElapsedTime &lt;int&gt;, # AirTime &lt;int&gt;, ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, Origin &lt;chr&gt;, Dest &lt;chr&gt;, # Distance &lt;int&gt;, TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, Cancelled &lt;int&gt;, # CancellationCode &lt;chr&gt;, Diverted &lt;int&gt;, ActualGroundTime &lt;int&gt; Ajouter la variable AverageSpeed (=Distance/AirTime) et ordonner la table selon les valeurs décroissantes de cette variable. &gt; hflights3 &lt;- hflights2 %&gt;% + mutate(AverageSpeed=Distance/AirTime) %&gt;% + arrange(desc(AverageSpeed)) Sélectionner les vols à destination de JFK. &gt; filter(hflights3,Dest==&quot;JFK&quot;) # A tibble: 695 x 23 Year Month DayofMonth DayOfWeek DepTime ArrTime UniqueCarrier FlightNum &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 2011 2 7 1 659 1045 JetBlue 620 2 2011 2 6 7 700 1045 JetBlue 620 3 2011 2 5 6 700 1113 JetBlue 620 4 2011 2 6 7 1529 1917 JetBlue 624 5 2011 1 24 1 707 1059 JetBlue 620 6 2011 1 24 1 1532 1923 JetBlue 624 7 2011 2 12 6 659 1105 JetBlue 620 8 2011 10 19 3 644 1043 JetBlue 620 9 2011 11 10 4 1629 2027 JetBlue 622 10 2011 2 8 2 654 1049 JetBlue 620 # … with 685 more rows, and 15 more variables: TailNum &lt;chr&gt;, # ActualElapsedTime &lt;int&gt;, AirTime &lt;int&gt;, ArrDelay &lt;int&gt;, DepDelay &lt;int&gt;, # Origin &lt;chr&gt;, Dest &lt;chr&gt;, Distance &lt;int&gt;, TaxiIn &lt;int&gt;, TaxiOut &lt;int&gt;, # Cancelled &lt;int&gt;, CancellationCode &lt;chr&gt;, Diverted &lt;int&gt;, # ActualGroundTime &lt;int&gt;, AverageSpeed &lt;dbl&gt; Calculer le nombre de vols à destination de JFK. &gt; hflights3 %&gt;% filter(Dest==&quot;JFK&quot;) %&gt;% summarise(numb_to_JFK=n()) # A tibble: 1 x 1 numb_to_JFK &lt;int&gt; 1 695 Créer un résumé de hflights1 qui contient : n : le nombre total de vols ; n_dest: le nombre total de destinations ; n_carrier : le nombre total de compagnies. &gt; hflights1 %&gt;% summarize(n_flights=n(),n_dest=n_distinct(Dest),n_carrier=n_distinct(UniqueCarrier)) # A tibble: 1 x 3 n_flights n_dest n_carrier &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 227496 116 15 Créer un résumé de hflights1 qui contient, pour les vols de la compagnie American, le nombre total de vols ; le nombre total de vols annulés ; la valeur moyenne de ArrDelay (attention à la gestion des NA…). &gt; hflights1 %&gt;% filter(UniqueCarrier==&quot;American&quot;) %&gt;% + summarize(n_fligths_Am=n(),n_can_Am=sum(Cancelled), + mean_ArrDelay_am=mean(ArrDelay,na.rm=TRUE)) # A tibble: 1 x 3 n_fligths_Am n_can_Am mean_ArrDelay_am &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 3244 60 0.892 Calculer pour chaque compagnie : le nombre total de vols ; La valeur moyenne de AirTime. &gt; hflights1 %&gt;% group_by(UniqueCarrier) %&gt;% + summarise(n_flights=n(),mean_AirTime=mean(AirTime,na.rm=TRUE)) # A tibble: 15 x 3 UniqueCarrier n_flights mean_AirTime &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 AirTran 2139 92.7 2 Alaska 365 254. 3 American 3244 69.7 4 American_Eagle 4648 93.8 5 Atlantic_Southeast 2204 104. 6 Continental 70032 145. 7 Delta 2641 97.8 8 ExpressJet 73053 83.2 9 Frontier 838 125. 10 JetBlue 695 184. 11 Mesa 79 122. 12 SkyWest 16061 113. 13 Southwest 45343 86.7 14 United 2072 157. 15 US_Airways 4082 134. Ordonner les compagnies en fonction des retards moyens au départ. &gt; hflights1 %&gt;% + group_by(UniqueCarrier) %&gt;% + filter(!is.na(DepDelay) &amp; DepDelay&gt;0) %&gt;% + summarise(meanDepDelay = mean(DepDelay)) %&gt;% + arrange(meanDepDelay) # A tibble: 15 x 2 UniqueCarrier meanDepDelay &lt;chr&gt; &lt;dbl&gt; 1 Continental 17.9 2 Alaska 20.8 3 Southwest 21.9 4 Frontier 22.7 5 Mesa 24.5 6 SkyWest 24.6 7 American 24.7 8 US_Airways 26.5 9 ExpressJet 26.9 10 United 28.8 11 Delta 32.4 12 AirTran 33.4 13 American_Eagle 37.9 14 JetBlue 43.5 15 Atlantic_Southeast 49.3 Exercice 3.5 (Tournois du grand chelemn au tennis) On considère le données sur les résultats de tennis dans les tournois du grand chelem en 2013. Les données, ainsi que le descriptif des variables, se trouvent à l’adresse https://archive.ics.uci.edu/ml/datasets/Tennis+Major+Tournament+Match+Statistics. On s’intéresse d’abord au tournoi masculin de Roland Garros. On répondra aux questions à l’aide des verbes dplyr. Importer les données. &gt; FrenchOpen_men_2013 &lt;- read_csv(&quot;data/FrenchOpen-men-2013.csv&quot;) &gt; RG2013 &lt;- FrenchOpen_men_2013 &gt; RG2013 # A tibble: 125 x 42 Player1 Player2 Round Result FNL.1 FNL.2 FSP.1 FSW.1 SSP.1 SSW.1 ACE.1 DBF.1 &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Pablo … Roger … 1 0 0 3 62 27 38 11 1 3 2 Somdev… Daniel… 1 1 3 0 62 54 38 22 7 3 3 Tobias… Paolo … 1 1 3 2 62 53 38 15 4 6 4 Julien… Ricard… 1 1 3 1 72 87 28 19 14 2 5 Lukas … Sam Qu… 1 0 0 3 52 31 48 22 4 4 6 Jan Ha… Denis … 1 1 3 1 70 58 30 18 4 4 7 Adrian… Pablo … 1 0 2 3 63 71 37 38 5 5 8 Gilles… Lleyto… 1 1 3 2 59 42 41 25 7 2 9 Philip… Marin … 1 0 0 3 56 27 44 13 0 6 10 Radek … Nick K… 1 0 0 3 63 62 37 29 5 4 # … with 115 more rows, and 30 more variables: WNR.1 &lt;dbl&gt;, UFE.1 &lt;dbl&gt;, # BPC.1 &lt;dbl&gt;, BPW.1 &lt;dbl&gt;, NPA.1 &lt;dbl&gt;, NPW.1 &lt;dbl&gt;, TPW.1 &lt;dbl&gt;, # ST1.1 &lt;dbl&gt;, ST2.1 &lt;dbl&gt;, ST3.1 &lt;dbl&gt;, ST4.1 &lt;dbl&gt;, ST5.1 &lt;dbl&gt;, # FSP.2 &lt;dbl&gt;, FSW.2 &lt;dbl&gt;, SSP.2 &lt;dbl&gt;, SSW.2 &lt;dbl&gt;, ACE.2 &lt;dbl&gt;, # DBF.2 &lt;dbl&gt;, WNR.2 &lt;dbl&gt;, UFE.2 &lt;dbl&gt;, BPC.2 &lt;dbl&gt;, BPW.2 &lt;dbl&gt;, # NPA.2 &lt;dbl&gt;, NPW.2 &lt;dbl&gt;, TPW.2 &lt;dbl&gt;, ST1.2 &lt;dbl&gt;, ST2.2 &lt;dbl&gt;, # ST3.2 &lt;dbl&gt;, ST4.2 &lt;dbl&gt;, ST5.2 &lt;dbl&gt; Afficher le nom des adversaires de Roger Federer. &gt; RG2013 %&gt;% filter(Player1==&quot;Roger Federer&quot; | Player2==&quot;Roger Federer&quot;) %&gt;% + select(Player1,Player2) # A tibble: 5 x 2 Player1 Player2 &lt;chr&gt; &lt;chr&gt; 1 Pablo Carreno-Busta Roger Federer 2 Somdev Devvarman Roger Federer 3 Julien Benneteau Roger Federer 4 Gilles Simon Roger Federer 5 Jo-Wilfried Tsonga Roger Federer Afficher le nom des demi-finalistes (ceux qui ont atteint le 6ème tour). &gt; RG2013 %&gt;% filter(Round==6) %&gt;% select(Player1,Player2) # A tibble: 2 x 2 Player1 Player2 &lt;chr&gt; &lt;chr&gt; 1 David Ferrer Jo-Wilfried Tsonga 2 Novak Djokovic Rafael Nadal Combien y a t-il eu de points disputés en moyenne par match ? Il faudra penser à ajouter dans la table une variable correspondant au nombre de points de chaque match (verbe mutate). &gt; RG2013 %&gt;% mutate(nb_points=TPW.1+TPW.2) %&gt;% select(nb_points) %&gt;% summarize_all(mean) # A tibble: 1 x 1 nb_points &lt;dbl&gt; 1 219. Combien y a t-il eu d’aces par match en moyenne ? &gt; RG2013 %&gt;% mutate(nb_aces=ACE.1+ACE.2) %&gt;% summarize(mean_aces=mean(nb_aces)) # A tibble: 1 x 1 mean_aces &lt;dbl&gt; 1 12.7 Combien y a t-il eu d’aces par match en moyenne à chaque tour ? &gt; RG2013 %&gt;% group_by(Round) %&gt;% mutate(nb_aces=ACE.1+ACE.2) %&gt;% + summarize(mean_aces=mean(nb_aces)) # A tibble: 7 x 2 Round mean_aces &lt;dbl&gt; &lt;dbl&gt; 1 1 13.5 2 2 13.2 3 3 12.6 4 4 9.12 5 5 7 6 6 10 7 7 6 Combien y a t-il eu de doubles fautes au total dans le tournoi (attention aux données manquantes, taper help(sum) pour voir comment les gérer) ? &gt; RG2013 %&gt;% mutate(nb_df=DBF.1+DBF.2) %&gt;% + summarize(nb_dbfaults=sum(nb_df,na.rm=TRUE)) # A tibble: 1 x 1 nb_dbfaults &lt;dbl&gt; 1 812 Importer les données pour le tournoi masculin de Wimbledon 2013. &gt; WIMB2013 &lt;- read_csv(&quot;data/Wimbledon-men-2013.csv&quot;) &gt; WIMB2013 # A tibble: 114 x 42 Player1 Player2 Round Result FNL.1 FNL.2 FSP.1 FSW.1 SSP.1 SSW.1 ACE.1 DBF.1 &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 B.Beck… A.Murr… 1 0 0 3 59 29 41 14 5 1 2 J.Ward Y-H.Lu 1 0 1 3 62 77 38 35 18 4 3 N.Mahut J.Hajek 1 1 3 0 72 44 28 10 17 3 4 T.Robr… A.Bogo… 1 1 3 0 77 40 23 12 6 0 5 R.Haase M.Youz… 1 0 0 3 68 61 32 15 7 2 6 M.Gicq… V.Posp… 1 0 0 3 59 41 41 27 7 6 7 A.Kuzn… A.Mont… 1 1 3 1 63 56 37 21 21 3 8 J.Tips… V.Troi… 1 0 0 3 61 47 39 21 3 1 9 M.Bagh… M.Cilic 1 0 0 3 61 31 39 16 4 5 10 K.De S… P.Lore… 1 1 3 0 67 56 33 21 22 6 # … with 104 more rows, and 30 more variables: WNR.1 &lt;dbl&gt;, UFE.1 &lt;dbl&gt;, # BPC.1 &lt;dbl&gt;, BPW.1 &lt;dbl&gt;, NPA.1 &lt;dbl&gt;, NPW.1 &lt;dbl&gt;, TPW.1 &lt;lgl&gt;, # ST1.1 &lt;dbl&gt;, ST2.1 &lt;dbl&gt;, ST3.1 &lt;dbl&gt;, ST4.1 &lt;dbl&gt;, ST5.1 &lt;dbl&gt;, # FSP.2 &lt;dbl&gt;, FSW.2 &lt;dbl&gt;, SSP.2 &lt;dbl&gt;, SSW.2 &lt;dbl&gt;, ACE.2 &lt;dbl&gt;, # DBF.2 &lt;dbl&gt;, WNR.2 &lt;dbl&gt;, UFE.2 &lt;dbl&gt;, BPC.2 &lt;dbl&gt;, BPW.2 &lt;dbl&gt;, # NPA.2 &lt;dbl&gt;, NPW.2 &lt;dbl&gt;, TPW.2 &lt;lgl&gt;, ST1.2 &lt;dbl&gt;, ST2.2 &lt;dbl&gt;, # ST3.2 &lt;dbl&gt;, ST4.2 &lt;dbl&gt;, ST5.2 &lt;dbl&gt; Concaténer les tables en ajoutant une variable permettant d’identifier le tournoi. On pourra utiliser bind_rows abev l’option .id. &gt; RG_WIMB2013 &lt;- bind_rows(&quot;RG&quot;=RG2013,&quot;WIMB&quot;=WIMB2013,.id=&quot;Tournament&quot;) Afficher les matchs de Federer pour chaque tournoi. &gt; RG_WIMB2013 %&gt;% filter(Player1==&quot;Roger Federer&quot; | + Player2==&quot;Roger Federer&quot; | + Player1==&quot;R.Federer&quot; | + Player2==&quot;R.Federer&quot;) # A tibble: 7 x 43 Tournament Player1 Player2 Round Result FNL.1 FNL.2 FSP.1 FSW.1 SSP.1 SSW.1 &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 RG Pablo … Roger … 1 0 0 3 62 27 38 11 2 RG Somdev… Roger … 2 0 0 3 61 19 39 16 3 RG Julien… Roger … 3 0 0 3 82 41 18 8 4 RG Gilles… Roger … 4 0 2 3 61 65 39 28 5 RG Jo-Wil… Roger … 5 1 3 0 75 46 25 10 6 WIMB V.Hane… R.Fede… 1 0 0 3 85 26 15 3 7 WIMB S.Stak… R.Fede… 2 1 3 1 66 83 34 36 # … with 32 more variables: ACE.1 &lt;dbl&gt;, DBF.1 &lt;dbl&gt;, WNR.1 &lt;dbl&gt;, UFE.1 &lt;dbl&gt;, # BPC.1 &lt;dbl&gt;, BPW.1 &lt;dbl&gt;, NPA.1 &lt;dbl&gt;, NPW.1 &lt;dbl&gt;, TPW.1 &lt;dbl&gt;, # ST1.1 &lt;dbl&gt;, ST2.1 &lt;dbl&gt;, ST3.1 &lt;dbl&gt;, ST4.1 &lt;dbl&gt;, ST5.1 &lt;dbl&gt;, # FSP.2 &lt;dbl&gt;, FSW.2 &lt;dbl&gt;, SSP.2 &lt;dbl&gt;, SSW.2 &lt;dbl&gt;, ACE.2 &lt;dbl&gt;, # DBF.2 &lt;dbl&gt;, WNR.2 &lt;dbl&gt;, UFE.2 &lt;dbl&gt;, BPC.2 &lt;dbl&gt;, BPW.2 &lt;dbl&gt;, # NPA.2 &lt;dbl&gt;, NPW.2 &lt;dbl&gt;, TPW.2 &lt;dbl&gt;, ST1.2 &lt;dbl&gt;, ST2.2 &lt;dbl&gt;, # ST3.2 &lt;dbl&gt;, ST4.2 &lt;dbl&gt;, ST5.2 &lt;dbl&gt; ou &gt; RG_WIMB2013 %&gt;% filter(grepl(&quot;Federer&quot;,Player2) | grepl(&quot;Federer&quot;,Player2)) # A tibble: 7 x 43 Tournament Player1 Player2 Round Result FNL.1 FNL.2 FSP.1 FSW.1 SSP.1 SSW.1 &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 RG Pablo … Roger … 1 0 0 3 62 27 38 11 2 RG Somdev… Roger … 2 0 0 3 61 19 39 16 3 RG Julien… Roger … 3 0 0 3 82 41 18 8 4 RG Gilles… Roger … 4 0 2 3 61 65 39 28 5 RG Jo-Wil… Roger … 5 1 3 0 75 46 25 10 6 WIMB V.Hane… R.Fede… 1 0 0 3 85 26 15 3 7 WIMB S.Stak… R.Fede… 2 1 3 1 66 83 34 36 # … with 32 more variables: ACE.1 &lt;dbl&gt;, DBF.1 &lt;dbl&gt;, WNR.1 &lt;dbl&gt;, UFE.1 &lt;dbl&gt;, # BPC.1 &lt;dbl&gt;, BPW.1 &lt;dbl&gt;, NPA.1 &lt;dbl&gt;, NPW.1 &lt;dbl&gt;, TPW.1 &lt;dbl&gt;, # ST1.1 &lt;dbl&gt;, ST2.1 &lt;dbl&gt;, ST3.1 &lt;dbl&gt;, ST4.1 &lt;dbl&gt;, ST5.1 &lt;dbl&gt;, # FSP.2 &lt;dbl&gt;, FSW.2 &lt;dbl&gt;, SSP.2 &lt;dbl&gt;, SSW.2 &lt;dbl&gt;, ACE.2 &lt;dbl&gt;, # DBF.2 &lt;dbl&gt;, WNR.2 &lt;dbl&gt;, UFE.2 &lt;dbl&gt;, BPC.2 &lt;dbl&gt;, BPW.2 &lt;dbl&gt;, # NPA.2 &lt;dbl&gt;, NPW.2 &lt;dbl&gt;, TPW.2 &lt;dbl&gt;, ST1.2 &lt;dbl&gt;, ST2.2 &lt;dbl&gt;, # ST3.2 &lt;dbl&gt;, ST4.2 &lt;dbl&gt;, ST5.2 &lt;dbl&gt; Comparer les nombres d’aces par matchs à chaque tours pour les tournois de Roland Garros et Wimbledon. &gt; RG_WIMB2013 %&gt;% group_by(Tournament,Round) %&gt;% + mutate(nb_aces=ACE.1+ACE.2) %&gt;% summarize(mean_ace=mean(nb_aces)) # A tibble: 14 x 3 # Groups: Tournament [2] Tournament Round mean_ace &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 RG 1 13.5 2 RG 2 13.2 3 RG 3 12.6 4 RG 4 9.12 5 RG 5 7 6 RG 6 10 7 RG 7 6 8 WIMB 1 21.1 9 WIMB 2 23.9 10 WIMB 3 24 11 WIMB 4 24.4 12 WIMB 5 26.5 13 WIMB 6 27.5 14 WIMB 7 13 ou pour une présentation plus synthétique &gt; RG_WIMB2013 %&gt;% group_by(Tournament,Round) %&gt;% + mutate(nb_aces=ACE.1+ACE.2) %&gt;% + summarize(mean_ace=mean(nb_aces)) %&gt;% + pivot_wider(names_from = &quot;Round&quot;,values_from = &quot;mean_ace&quot;) # A tibble: 2 x 8 # Groups: Tournament [2] Tournament `1` `2` `3` `4` `5` `6` `7` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 RG 13.5 13.2 12.6 9.12 7 10 6 2 WIMB 21.1 23.9 24 24.4 26.5 27.5 13 3.2.5 Compléments : Tidy data avec tidyr L’utilisation de dplyr et de ggplot (que nous verrons dans la partie suivante) suppose que les données sont présentées sous un format adéquat : une ligne est un individu et une colonne une variable, on parle alors de tidy data. Cela n’est pas toujours le cas en pratique, considérons par exemple le tableau suivant qui presente les taux de chômage des départements français en 2002, 2006, 2011 &gt; df &lt;- read_delim(&quot;data/tauxchomage.csv&quot;,delim=&quot;;&quot;) %&gt;% select(-1) &gt; df # A tibble: 96 x 4 NOM_DPT TCHOMB1T01 TCHOMB1T06 TCHOMB1T11 &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Ain 3.9 5.9 6.6 2 Aisne 10.6 12 13.2 3 Allier 9 9.2 9.7 4 Alpes-de-Haute-Provence 9.5 9.7 10.3 5 Hautes-Alpes 7.1 7.7 8.3 6 Alpes-Maritimes 9.1 8.9 9.2 7 Ardèche 8.1 9.6 9.7 8 Ardennes 11.5 12.8 10.9 9 Ariège 9.2 10.1 10.6 10 Aube 8.2 10 10 # … with 86 more rows Ce tableau n’est pas tidy dans le sens où les variables mesurées sont le département l’année le taux de chômage Nous verrons qu’il n’est par exemple pas possible de faire un boxplot permettant de visualiser la distribution du taux de chômage en fonction de l’année à l’aide de ggplot2. Pour passer au format tidy il faut assembler les 3 colonnes correspondant aux taux de chômage en une seule colonne et ajouter une colonne qui permette d’identifier l’année. La fonction pivot_longer du package tidyr permet de faire cela : &gt; df1 &lt;- df %&gt;% pivot_longer(-NOM_DPT,names_to=&quot;Année&quot;,values_to=&quot;TCHOM&quot;) %&gt;% + mutate(Année=fct_recode(Année,&quot;2001&quot;=&quot;TCHOMB1T01&quot;,&quot;2006&quot;=&quot;TCHOMB1T06&quot;,&quot;2011&quot;=&quot;TCHOMB1T11&quot;)) &gt; df1 # A tibble: 288 x 3 NOM_DPT Année TCHOM &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; 1 Ain 2001 3.9 2 Ain 2006 5.9 3 Ain 2011 6.6 4 Aisne 2001 10.6 5 Aisne 2006 12 6 Aisne 2011 13.2 7 Allier 2001 9 8 Allier 2006 9.2 9 Allier 2011 9.7 10 Alpes-de-Haute-Provence 2001 9.5 # … with 278 more rows Il sera alors aisé de faire le boxplot souhaité avec &gt; ggplot(df1)+aes(x=Année,y=TCHOM)+geom_boxplot() L’opération inverse peut être effectuée avec pivot_wider : &gt; df1 %&gt;% pivot_wider(names_from=&quot;Année&quot;,values_from=&quot;TCHOM&quot;) # A tibble: 96 x 4 NOM_DPT `2001` `2006` `2011` &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Ain 3.9 5.9 6.6 2 Aisne 10.6 12 13.2 3 Allier 9 9.2 9.7 4 Alpes-de-Haute-Provence 9.5 9.7 10.3 5 Hautes-Alpes 7.1 7.7 8.3 6 Alpes-Maritimes 9.1 8.9 9.2 7 Ardèche 8.1 9.6 9.7 8 Ardennes 11.5 12.8 10.9 9 Ariège 9.2 10.1 10.6 10 Aube 8.2 10 10 # … with 86 more rows Le package tidyr possède plusieurs autres verbes qui pourront aider l’utilisateur à mettre la table sous le meilleur format pour les analyses. Citons par exemple le verbe separate qui va séparer une colonne en plusieurs : &gt; df &lt;- tibble(date=as.Date(c(&quot;01/03/2015&quot;,&quot;05/18/2017&quot;, + &quot;09/14/2018&quot;),&quot;%m/%d/%Y&quot;),temp=c(18,21,15)) &gt; df # A tibble: 3 x 2 date temp &lt;date&gt; &lt;dbl&gt; 1 2015-01-03 18 2 2017-05-18 21 3 2018-09-14 15 &gt; df1 &lt;- df %&gt;% separate(date,into = c(&quot;year&quot;,&quot;month&quot;,&quot;day&quot;)) &gt; df1 # A tibble: 3 x 4 year month day temp &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 2015 01 03 18 2 2017 05 18 21 3 2018 09 14 15 ou le verbe unite qui fera l’opération inverse &gt; df1 %&gt;% unite(date,year,month,day,sep=&quot;/&quot;) # A tibble: 3 x 2 date temp &lt;chr&gt; &lt;dbl&gt; 1 2015/01/03 18 2 2017/05/18 21 3 2018/09/14 15 Citons enfin les verbes : separate_rows qui permettra de séparer des informations en plusieurs lignes ; extract pour créer de nouvelles colonnes ; complete "],
["ggplot.html", "Chapitre 4 Ggplot", " Chapitre 4 Ggplot "],
["références.html", "Références", " Références "]
]
